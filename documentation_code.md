# Подробная документация по коду проекта «TodoApp (SQLite + Tkinter)»

Документ описывает архитектуру и назначение **каждого класса/метода/функции**, присутствующих в исходном коде проекта.  
Код расположен в модулях:

- `RoutineApp (2)/todo_app/core/models.py`
- `RoutineApp (2)/todo_app/core/database.py`
- `RoutineApp (2)/todo_app/main_gui.py`

---

## 1. Модуль `core/models.py`

### `Task` (dataclass)
**Назначение:** модель предметной области «Задача». Используется как контейнер данных между БД (`TodoDatabase`) и GUI.

**Поля:**
- `id: Optional[int]` — идентификатор записи (первичный ключ в SQLite). `None` возможен до сохранения.
- `title: str` — заголовок задачи (обязательное поле).
- `description: str = ""` — описание задачи.
- `completed: bool = False` — логический признак завершения.
- `category: str = "Без категории"` — категория задачи.
- `status: str = "не выполнено"` — строковый статус (например: `не выполнено`, `в процессе`, `выполнено`).
- `priority: str = "нет"` — приоритет (`срочно`, `важно`, `обычно`, `нет`).
- `due_date: Optional[str] = None` — срок выполнения (строка). В коде встречаются форматы:
  - ожидаемый в `is_overdue`: `"YYYY-MM-DD HH:MM"`
  - фактически при добавлении из GUI: `"YYYY-MM-DD HH:MM:SS"` (см. замечание ниже)
- `created_at: Optional[str] = None` — дата/время создания (строка).

#### `Task.get_priority_color() -> tuple`
**Назначение:** вычисляет RGBA-цвет фона для визуального выделения задачи по приоритету.

**Логика:**
- если `status == "выполнено"` → возвращает «серый» цвет, чтобы визуально приглушить завершённые задачи;
- иначе выбирает цвет из словаря соответствия приоритетов.

**Возвращаемое значение:** `tuple` формата `(r, g, b, a)` (float).

#### `Task.is_overdue() -> bool`
**Назначение:** определяет, является ли задача просроченной относительно текущего времени.

**Логика:**
- если `due_date` отсутствует или статус `выполнено` → `False`;
- пытается распарсить `due_date` форматом `"%Y-%m-%d %H:%M"`;
- сравнивает `datetime.now()` и `due`;
- при любой ошибке парсинга возвращает `False`.

**Замечание по данным:** если срок хранится как `"YYYY-MM-DD HH:MM:SS"`, то текущая реализация **не распознает** его как дату (парсинг упадёт), и просрочка не будет определяться. Это важно учитывать при тестировании и развитии.

---

## 2. Модуль `core/database.py`

### `TodoDatabase`
**Назначение:** слой доступа к данным (DAO/Repository). Инкапсулирует работу с SQLite: создание схемы, миграцию, CRUD-операции для задач и операции с категориями.

#### `TodoDatabase.__init__(db_path: str = "todo.db")`
**Назначение:** создаёт объект БД и инициализирует хранилище.

**Параметры:**
- `db_path` — путь к файлу SQLite. По умолчанию `"todo.db"` (относительно текущего рабочего каталога).

**Побочные эффекты:** вызывает `init_db()`.

#### `TodoDatabase.get_connection()`
**Назначение:** возвращает соединение `sqlite3.Connection` к БД.

**Возвращаемое значение:** `sqlite3.connect(self.db_path)`.

**Замечание:** соединение создаётся на каждый вызов; управление закрытием происходит через контекстный менеджер `with`.

#### `TodoDatabase.init_db()`
**Назначение:** обеспечивает существование таблиц и выполняет простую миграцию при изменении схемы.

**Логика:**
1. Проверяет наличие таблицы `tasks` через `sqlite_master`.
2. Если таблица есть:
   - запрашивает структуру `PRAGMA table_info(tasks)`;
   - проверяет наличие колонок из `required_columns = ['category','status','priority','due_date','created_at']`;
   - если каких-то колонок нет → создаёт `tasks_new` с новой схемой;
   - переносит данные из старой таблицы в `tasks_new` с заполнением новых колонок значениями по умолчанию;
   - удаляет старую таблицу `tasks`, переименовывает `tasks_new` в `tasks`.
3. Если таблицы `tasks` нет — создаёт её «с нуля».
4. Создаёт таблицу `categories` (если не существует).
5. Если `categories` пуста — добавляет набор стандартных категорий.

**Итог:** в БД гарантированно есть таблицы `tasks` и `categories`, а также базовые категории.

#### `TodoDatabase.add_task(title: str, description: str = "", category: str = "Без категории", priority: str = "нет", due_date: Optional[str] = None) -> int`
**Назначение:** добавляет новую задачу в `tasks`.

**Параметры:**
- `title` — заголовок;
- `description` — описание;
- `category` — категория;
- `priority` — приоритет;
- `due_date` — срок (строка или `None`).

**Логика:**
- добавляет категорию в `categories` через `INSERT OR IGNORE`;
- формирует `created_at` как текущие дата/время `"%Y-%m-%d %H:%M:%S"`;
- выполняет `INSERT INTO tasks (...) VALUES (...)`.

**Возвращаемое значение:** `cursor.lastrowid` (id созданной записи).

#### `TodoDatabase.update_task(task_id: int, title: str, description: str, category: str, priority: str, due_date: Optional[str])`
**Назначение:** обновляет основные поля задачи (кроме статуса/флага выполнения).

**Параметры:**
- `task_id` — идентификатор задачи;
- `title`, `description`, `category`, `priority`, `due_date` — новые значения.

**Логика:**
- гарантирует наличие категории в `categories` (`INSERT OR IGNORE`);
- выполняет `UPDATE tasks SET title=?, description=?, category=?, priority=?, due_date=? WHERE id=?`.

**Замечание:** метод не обновляет `updated_at` (такое поле в схеме отсутствует), и не меняет `status/completed` — это делает отдельный метод.

#### `TodoDatabase.update_task_status(task_id: int, status: str)`
**Назначение:** обновляет статус задачи и синхронизирует булевый признак `completed`.

**Логика:**
- `completed = 1`, если `status == "выполнено"`, иначе `0`;
- выполняет `UPDATE tasks SET status=?, completed=? WHERE id=?`.

#### `TodoDatabase.get_all_tasks() -> List[Task]`
**Назначение:** возвращает список всех задач.

**Логика:** выполняет `SELECT ... FROM tasks ORDER BY id`, затем преобразует строки через `_row_to_task`.

#### `TodoDatabase.search_tasks(query: str) -> List[Task]`
**Назначение:** полнотекстоподобный поиск задач по подстроке в заголовке или описании.

**Параметры:**
- `query` — строка поиска.

**Логика:**
- формирует `search_pattern = f"%{query}%"`;
- выполняет `WHERE title LIKE ? OR description LIKE ?`.

#### `TodoDatabase.filter_tasks(category: Optional[str] = None, priority: Optional[str] = None, status: Optional[str] = None, date_from: Optional[str] = None, date_to: Optional[str] = None, sort_order: str = "ASC") -> List[Task]`
**Назначение:** выборка задач по набору критериев фильтрации и сортировки.

**Параметры:**
- `category`, `priority`, `status` — фильтры по точному совпадению;
- `date_from`, `date_to` — фильтр по `due_date` (строковое сравнение);
- `sort_order` — `"ASC"` или `"DESC"` по `id`.

**Логика:**
- собирает SQL динамически, начиная с `WHERE 1=1`;
- добавляет условия и параметры только для указанных фильтров;
- применяет сортировку по `id`.

**Замечания:**
- фильтрация по датам сделана через сравнение строк `due_date >= ?`; корректность зависит от единообразного формата дат.
- в GUI `date_from/date_to` не используются, но метод поддерживает такую возможность.

#### `TodoDatabase.get_categories() -> List[str]`
**Назначение:** возвращает список категорий из таблицы `categories`.

**Логика:** `SELECT name FROM categories ORDER BY name`.

#### `TodoDatabase.delete_category(category_name: str)`
**Назначение:** удаляет категорию и переводит связанные задачи в «Без категории».

**Логика:**
- удаляет строку в `categories`;
- обновляет задачи: `UPDATE tasks SET category='Без категории' WHERE category=?`;
- выполняет `commit()`.

#### `TodoDatabase.toggle_task(task_id: int)`
**Назначение:** переключает флаг завершенности `completed` и синхронизирует `status`.

**Логика:**
- читает текущее значение `completed`;
- инвертирует;
- устанавливает `status = "выполнено"` или `"не выполнено"`;
- выполняет `UPDATE tasks ...`.

**Замечание:** в текущем GUI этот метод напрямую не используется (статус меняют через `update_task_status`).

#### `TodoDatabase.delete_task(task_id: int)`
**Назначение:** физически удаляет задачу.

**Логика:** `DELETE FROM tasks WHERE id=?`.

#### `TodoDatabase.get_task_by_id(task_id: int) -> Optional[Task]`
**Назначение:** возвращает задачу по id или `None`.

**Логика:** `SELECT ... FROM tasks WHERE id=?`, затем `_row_to_task`.

#### `TodoDatabase._row_to_task(row) -> Task`
**Назначение:** внутренний метод преобразования строки выборки SQLite в объект `Task`.

**Логика:** маппит индексы `row[i]` на поля `Task`; использует значения по умолчанию при отсутствии колонок (защита на случай различий схем).

---

## 3. Модуль `main_gui.py`

Модуль содержит GUI на Tkinter: диалоги, виджеты и главный класс приложения.

### Глобальные элементы

#### Импорт `tkcalendar.Calendar` и флаг `CALENDAR_AVAILABLE`
**Назначение:** календарь доступен только при установленном пакете `tkcalendar`.  
Если импорт не удался — календарные функции показывают сообщение.

#### `COLORS: dict`
**Назначение:** централизованная цветовая схема тёмной темы.  
Используется всеми виджетами для единообразного оформления.

---

### `CalendarDialog(tk.Toplevel)`
**Назначение:** модальное окно выбора даты. При наличии `tkcalendar` показывает календарь.

#### `CalendarDialog.__init__(parent, current_date=None)`
**Параметры:**
- `parent` — родительское окно;
- `current_date` — строка даты (ожидается `"YYYY-MM-DD"`), используется как начальная выбранная дата.

**Логика:**
- делает окно модальным (`transient`, `grab_set`);
- создаёт календарь (если `CALENDAR_AVAILABLE`) с предустановкой текущей даты;
- иначе выводит инструкцию установки `tkcalendar`;
- добавляет кнопки: «Выбрать», «Сегодня», «Отмена»;
- центрирует окно;
- сохраняет результат выбора в `self.selected_date`.

#### `CalendarDialog._select_date()`
**Назначение:** считывает выбранную дату из виджета календаря, приводит к формату `"YYYY-MM-DD"` и закрывает диалог.

#### `CalendarDialog._select_today()`
**Назначение:** устанавливает выбор на текущий день (в календаре).

---

### `TimePickerDialog(tk.Toplevel)`
**Назначение:** модальное окно выбора времени через `Spinbox` (часы/минуты).

#### `TimePickerDialog.__init__(parent, current_time=None)`
**Параметры:**
- `current_time` — строка `"HH:MM"` или `None`.

**Логика:**
- делает окно модальным;
- определяет начальные значения часов/минут;
- строит интерфейс со спинбоксами;
- предоставляет быстрый выбор (`09:00`, `12:00`, `18:00`, `Сейчас`);
- сохраняет результат в `self.selected_time` как `"HH:MM"`.

#### `TimePickerDialog._set_quick_time(time_str)`
**Назначение:** устанавливает часы/минуты быстрым выбором.
- если `time_str is None` → берёт текущее время,
- иначе парсит строку `"HH:MM"`.

#### `TimePickerDialog._select_time()`
**Назначение:** читает значения из `Spinbox`, формирует строку `"HH:MM"` и закрывает диалог.

---

### `DateTimeInput(tk.Frame)`
**Назначение:** составной виджет ввода срока выполнения (дата + время) с кнопками открытия календаря и выбора времени. Используется в `EditTaskDialog`.

#### `DateTimeInput.__init__(parent, **kwargs)`
**Логика:**
- создаёт два поля `Entry`: дата и время;
- добавляет кнопки-иконки для открытия диалогов;
- реализует placeholder-поведение («ГГГГ-ММ-ДД», «ЧЧ:ММ») через флаги `_date_placeholder`, `_time_placeholder`.

#### `DateTimeInput._open_calendar()`
**Назначение:** открывает `CalendarDialog`, записывает выбранную дату в поле.

#### `DateTimeInput._on_date_focus_in(event)` / `_on_date_focus_out(event)`
**Назначение:** управление placeholder для даты (очистка при фокусе и восстановление при пустом значении).

#### `DateTimeInput._open_time_picker()`
**Назначение:** открывает `TimePickerDialog`, записывает выбранное время в поле.

#### `DateTimeInput._on_time_focus_in(event)` / `_on_time_focus_out(event)`
**Назначение:** управление placeholder для времени.

#### `DateTimeInput.get_datetime() -> Optional[str]`
**Назначение:** возвращает введённые дату и время одной строкой `"YYYY-MM-DD HH:MM"`.

**Логика:**
- если оба значения введены и не являются placeholder → валидирует через `datetime.strptime`;
- при ошибке формата возвращает `None`.

#### `DateTimeInput.set_datetime(datetime_str: str)`
**Назначение:** заполняет поля даты/времени из строки вида `"YYYY-MM-DD HH:MM"`.

#### `DateTimeInput.clear()`
**Назначение:** очищает поля и возвращает placeholder.

---

### `ManageCategoriesDialog(tk.Toplevel)`
**Назначение:** окно управления категориями (просмотр/добавление/удаление). Работает с таблицей `categories`.

#### `ManageCategoriesDialog.__init__(parent, db, update_callback)`
**Параметры:**
- `db` — экземпляр `TodoDatabase`;
- `update_callback` — функция, вызываемая после изменений (обновление комбобоксов/списка задач в главном окне).

**Логика:** создаёт интерфейс и загружает категории.

#### `ManageCategoriesDialog._create_widgets()`
**Назначение:** строит UI: поле ввода, кнопку добавления, список категорий, кнопку удаления и закрытия.

#### `ManageCategoriesDialog._load_categories()`
**Назначение:** загружает категории из БД и заполняет `Listbox`.

#### `ManageCategoriesDialog._add_category()`
**Назначение:** добавляет новую категорию.
- валидирует непустое имя;
- выполняет `INSERT INTO categories`;
- при нарушении `UNIQUE` показывает ошибку;
- обновляет список и вызывает `update_callback`.

#### `ManageCategoriesDialog._delete_category()`
**Назначение:** удаляет выбранную категорию.
- проверяет выбор;
- запрашивает подтверждение;
- вызывает `db.delete_category`, затем обновляет UI и главный экран.

---

### `ModernButton(tk.Button)`
**Назначение:** кнопка с эффектом наведения (смена фона).

#### `ModernButton.__init__(..., text, command, bg_color=None, hover_color=None, fg_color=None, width=120, height=35, **kwargs)`
**Особенности:**
- принимает размеры в пикселях, затем приблизительно переводит `width` в «символьную ширину» (`char_width = width // 8`) — это связано с тем, что Tkinter измеряет ширину кнопки в символах;
- бинды на `<Enter>/<Leave>` для hover-эффекта.

#### `ModernButton._on_enter(e)` / `ModernButton._on_leave(e)`
**Назначение:** переключает цвет фона между обычным и hover.

---

### `EditTaskDialog(tk.Toplevel)`
**Назначение:** модальное окно редактирования одной задачи (заголовок, описание, категория, статус, приоритет, срок).

#### `EditTaskDialog.__init__(parent, task: Task, db: TodoDatabase, callback)`
**Параметры:**
- `task` — редактируемая задача;
- `db` — доступ к БД;
- `callback` — функция обновления списка задач после сохранения.

**Логика:** строит UI, делает окно модальным, центрирует.

#### `EditTaskDialog._get_all_categories()`
**Назначение:** получает категории из БД (прокси к `db.get_categories()`).

#### `EditTaskDialog._create_widgets()`
**Назначение:** строит UI редактирования:
- `Entry` для заголовка,
- `Text` для описания,
- `Combobox` для категории, статуса, приоритета,
- `DateTimeInput` для срока,
- кнопки «Сохранить/Отмена».

#### `EditTaskDialog._save_task()`
**Назначение:** сохраняет изменения задачи в БД.

**Логика:**
- валидирует, что `title` непустой;
- собирает данные из UI;
- вызывает:
  - `db.update_task(...)` (title/description/category/priority/due_date),
  - `db.update_task_status(...)` (status + completed);
- вызывает `callback()` и закрывает диалог.

---

### `TaskItem(tk.Frame)`
**Назначение:** виджет «карточка задачи» для отображения в списке: заголовок, описание, бейджи и элементы управления.

#### `TaskItem.__init__(parent, task: Task, db: TodoDatabase, refresh_callback, **kwargs)`
**Параметры:**
- `task` — задача для отображения;
- `db` — доступ к БД;
- `refresh_callback` — функция обновления списка после изменений (статус/удаление и т.д.).

**Логика:**
- настраивает рамку и hover-эффект;
- создаёт внутренние элементы через `_create_widgets()`.

#### `TaskItem._on_enter(e)` / `TaskItem._on_leave(e)`
**Назначение:** визуальная подсветка карточки при наведении (фон и рамка).

#### `TaskItem._create_widgets()`
**Назначение:** формирует содержимое карточки:
- цветной индикатор приоритета;
- заголовок `#id title` + пометка просрочки через `task.is_overdue()`;
- (опционально) сокращённое описание;
- бейджи: категория, приоритет, due_date, статус;
- элементы управления: combobox статуса и кнопки «Редактировать/Удалить».

#### `TaskItem._create_badge(parent, text, color)`
**Назначение:** создаёт label-бейдж заданного цвета и добавляет hover-обработчики.

#### `TaskItem._get_priority_color() -> str`
**Назначение:** определяет цвет индикатора приоритета (в терминах цветовой схемы GUI).

**Отличие от `Task.get_priority_color`:**
- здесь возвращается hex-цвет из `COLORS`, а не RGBA tuple.

#### `TaskItem._on_status_change(event)`
**Назначение:** обработчик изменения статуса через combobox:
- вызывает `db.update_task_status(id, new_status)`,
- затем `refresh_callback()`.

#### `TaskItem._edit_task()`
**Назначение:** открывает `EditTaskDialog` для текущей задачи.
- получает «актуальную» задачу через `db.get_task_by_id` (защита от устаревших данных);
- если задача найдена — создаёт диалог редактирования.

#### `TaskItem._delete_task()`
**Назначение:** удаляет задачу после подтверждения.
- спрашивает `askyesno`,
- вызывает `db.delete_task(id)`,
- затем `refresh_callback()`.

---

### `FilterPanel(tk.Frame)`
**Назначение:** панель поиска и фильтрации (категория, приоритет, статус, сортировка).

#### `FilterPanel.__init__(parent, db: TodoDatabase, apply_callback, **kwargs)`
**Параметры:**
- `db` — источник категорий;
- `apply_callback` — вызывается при изменении фильтров/поиска.

#### `FilterPanel._create_widgets()`
**Назначение:** строит интерфейс панели:
- строка поиска с `trace("w", ...)` — фильтрация «на лету»;
- combobox категории, приоритета, статуса;
- combobox сортировки.

#### `FilterPanel.update_category_values()`
**Назначение:** обновляет список категорий в combobox.
- формирует `["Все"] + db.get_categories()`;
- если текущее значение не существует — сбрасывает на `"Все"`.

#### `FilterPanel._clear_search()`
**Назначение:** очищает строку поиска.

#### `FilterPanel._reset_filters()`
**Назначение:** сбрасывает фильтры к значениям по умолчанию.
**Замечание:** в текущем UI метод не привязан к кнопке, но готов к использованию.

#### `FilterPanel.get_filters() -> dict`
**Назначение:** возвращает структуру текущих фильтров для применения в `TodoApp.apply_filters()`.

**Возвращаемые ключи:**
- `search` — строка поиска,
- `category`, `priority`, `status` — `None` или конкретное значение,
- `sort_order` — `"ASC"` или `"DESC"`.

**Замечание:** логика `sort_order` завязана на проверку подстроки `"конца"` в тексте сортировки, при том что значения combobox — `["Старые", "Новые"]`. Это влияет на корректность сортировки (фактически почти всегда будет `"ASC"`).

---

### `TodoApp`
**Назначение:** главный класс приложения: инициализация окна, виджетов, обработчиков, синхронизация UI с БД.

#### `TodoApp.__init__(root)`
**Параметры:**
- `root` — `tk.Tk()`.

**Логика:**
- создаёт `TodoDatabase()`;
- настраивает окно (заголовок, размер, фон);
- вызывает `_setup_styles()`, `_create_widgets()`;
- обновляет список задач через `refresh_tasks()`.

#### `TodoApp._get_all_categories()`
**Назначение:** прокси к `db.get_categories()` для заполнения UI.

#### `TodoApp._setup_styles()`
**Назначение:** конфигурирует `ttk.Style()` под тёмную тему:
- базовые стили `TFrame`, `TLabel`;
- внешний вид `TCombobox`;
- стиль вертикального `Scrollbar`.

#### `TodoApp._create_widgets()`
**Назначение:** создаёт весь интерфейс главного окна:
1. секция «Добавить задачу» (ввод title/description/category/priority/date/time);
2. кнопки: добавление задачи и управление категориями;
3. панель фильтров `FilterPanel`;
4. прокручиваемый список задач:
   - `Canvas` + `Scrollbar`,
   - `tasks_frame` как внутренний контейнер,
   - бинды колеса мыши.

#### `TodoApp._on_mousewheel(event)`
**Назначение:** вертикальная прокрутка списка задач (учитывает Windows/macOS через `event.delta` и Linux через `Button-4/5`).

#### `TodoApp._open_manage_categories()`
**Назначение:** открывает `ManageCategoriesDialog`.

**Внутренняя функция `update_categories()`:**
- обновляет значения категории в форме добавления,
- обновляет категории в `FilterPanel`,
- обновляет список задач.

#### `TodoApp._open_calendar_dialog()`
**Назначение:** открывает `CalendarDialog` для поля даты в форме добавления и записывает выбранную дату.

#### `TodoApp._open_time_picker_dialog()`
**Назначение:** открывает `TimePickerDialog` для поля времени в форме добавления и записывает выбранное время.

#### `TodoApp._get_datetime_from_entries()`
**Назначение:** формирует объект `datetime` из полей формы добавления (дата/время).

**Логика:**
- если дата не задана (placeholder или пусто) → `None`;
- если время не задано → использует `"00:00"`;
- парсит `datetime.strptime(..., "%Y-%m-%d %H:%M")`;
- при ошибке → `None`.

#### `TodoApp._add_task()`
**Назначение:** обработчик кнопки «Добавить задачу».

**Логика:**
- проверяет непустой заголовок;
- читает описание, категорию, приоритет;
- преобразует дату/время через `_get_datetime_from_entries()`;
- если дата есть → форматирует как строку `"%Y-%m-%d %H:%M:%S"` и передаёт в `db.add_task(...)`;
- обновляет список категорий в combobox;
- очищает поля ввода, сбрасывает placeholder;
- вызывает `refresh_tasks()`.

#### `TodoApp.apply_filters()`
**Назначение:** применяет текущие фильтры/поиск и отображает результат.

**Логика:**
- получает фильтры из `filter_panel.get_filters()`;
- если `search` не пустой → `db.search_tasks(search)`;
- иначе → `db.filter_tasks(category, priority, status, sort_order)`;
- передаёт список в `_display_tasks(tasks)`.

#### `TodoApp.refresh_tasks()`
**Назначение:** единая точка обновления списка задач.
- обновляет список категорий в фильтрах,
- затем применяет фильтры.

#### `TodoApp._display_tasks(tasks)`
**Назначение:** отображает список задач в `tasks_frame`.

**Логика:**
- удаляет все дочерние виджеты внутри `tasks_frame`;
- если список пуст — выводит сообщение «Задач не найдено»;
- иначе создаёт `TaskItem` для каждой задачи и добавляет в список;
- обновляет `scrollregion` канвы.

---

### `main()`
**Назначение:** точка входа в приложение.
- создаёт `tk.Tk()`,
- инициализирует `TodoApp`,
- запускает цикл `mainloop()`.

---

## 4. Краткие связи между компонентами

- GUI (`main_gui.py`) **не работает напрямую** с SQLite: он использует `TodoDatabase`.
- `TodoDatabase` возвращает данные как `Task` (модель из `core/models.py`).
- Отображение каждой задачи инкапсулировано в `TaskItem`, а редактирование — в `EditTaskDialog`.
- Категории имеют отдельную таблицу `categories` и отдельный диалог управления.

---

Если хочешь, я могу:
1) оформить эту документацию как реальный файл `RoutineApp (2)/documentation.md` в проекте,  
2) дополнить её диаграммой (словесной) потоков данных “UI → DB → UI”,  
3) или добавить раздел «Замечания и потенциальные дефекты» (про формат `due_date` и сортировку). 
